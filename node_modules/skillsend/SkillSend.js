'use strict';

const axios = require('axios');

  function parseType(callingFile) {
    return  (
      callingFile.substring(callingFile.lastIndexOf("/")+1,
                            callingFile.lastIndexOf(".")) );
  }
  
  async function send(type,method,mode,id, msgbody) {
    try {
      // ignore '/'+mode as always before
      const dest=strapi.config.currentEnvironment.skillsBackendURL
                 +type.toLowerCase()+'/'+id;  //+'/'+mode;
      strapi.log.info('Send dest:'+dest);
      const resp = await method(dest, msgbody);

      strapi.log.info('Send resp:'+resp.status);

    } catch(error) {
      strapi.log.error('send error '+error);
      throw new Error('send to skillsDB failed'); 
    }
  }

  async function getBusnObj(type,id) {
    const criteria={_id: id};
    strapi.log.info('criteria '+JSON.stringify(criteria)); 

    const promise=global[type]['findOne'](criteria).exec();  
    //const promise=Qualification.findOne(criteria).exec();  
    const busnobj=await promise;

    strapi.log.info('test busnobj '+JSON.stringify(busnobj));

    return busnobj;
  }

  // Generate a simple message body to send out - with no expanded 1:n
  async function genMsgBody(update) {
    var msgbody=JSON.parse(JSON.stringify(update));
    msgbody.$set=undefined;
    msgbody.$setOnInsert=undefined;
    return msgbody;
  }

  // Example adding Category to Restaurant - not in Ref Data so far
  async function genMsgBodyExpandCategory(update) {
    const catcriteria={_id: update.category};
    strapi.log.info('catcriteria '+JSON.stringify(catcriteria)); 

    const categorypromise=Category.findOne(catcriteria).exec();  
    const category=await categorypromise;

    strapi.log.info('category '+JSON.stringify(category));

    var msgbody=genMsgBody(update);
    msgbody.category=category;

    return msgbody;
  }

/**
 * Lifecycle callbacks for the `Cmdmodel` model.
 */

module.exports = {

  // This is for true UPDATES it only fires once saved without error 
  afterUpdate: async (callingFile,model,result) => {
    /* Commented out as going for remote site checking
    var type=parseType(callingFile);

    if(Object.keys(model._update).length<=3) {
      // update follows create to set key
      strapi.log.info('ignoring as update is key only');
      return;
    }

    var msgbody=await genMsgBody(model._update);
    await send(type,axios.put,'after',model._id,msgbody);
    */
  },

  // This is for CREATE 
  // use it if we hand off to the main site to report errors
  beforeCreate: async (callingFile,model) => {
    var type=parseType(callingFile);

    strapi.log.info('beforeCreate '+JSON.stringify(model));
    var msgbody=await genMsgBody(model);
    await send(type,axios.post,'before',model.id,msgbody);
  },
  
  // This is for UPDATE when we can hand off to the main site 
  // This is for CREATE it only fires once saved without error 
  beforeUpdate: async (callingFile,model) => {
    var type=parseType(callingFile);

    strapi.log.info('beforeUpdate '+JSON.stringify(model._update));

    if(Object.keys(model._update).length<=1) {
      // This is for CREATE it only fires once saved without error 
      // use it if we CAN'T hand off to the main site to report errors
      // but rather want to be 100% sure it is committed locally
      /* Commented out as going for remote site checking

      // update follows create to set key
      var savedrest=await getBusnObj(type,model._update.id);

      if(savedrest!=null) {
        strapi.log.info('beforeUpdate test failed');
        var msgbody=await genMsgBody(savedrest);
        await send(type,axios.post,'after',model._update.id,msgbody);
      }
      */
    } else {
        var msgbody=await genMsgBody(model._update);
        await send(type,axios.put,'before',model._update.id,msgbody);
    }
  }

};
